<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <title>Sprite correndo pelas paredes (rotação correta)</title>
  <style>
    body { display:flex; gap:20px; align-items:flex-start; padding:20px; font-family:system-ui,Segoe UI,Roboto; }
    canvas { border:3px solid #1e88e5; }
    .info { max-width:340px; font-size:14px; color:#222; }
    .hint { margin-top:10px; color:#555; font-size:13px; }
  </style>
</head>
<body>
  <canvas id="myCanvas" width="300" height="300"></canvas>
  <div class="info">
    <strong>Instruções rápidas</strong>
    <div class="hint">
      Se o boneco estiver a "olhar" na direção errada, muda a variável <code>orientationOffset</code>:
      <ul>
        <li><code>0</code> — sprite já orientado para a direita</li>
        <li><code>Math.PI/2</code> — sprite orientado para baixo</li>
        <li><code>Math.PI</code> — sprite orientado para a esquerda</li>
        <li><code>-Math.PI/2</code> — sprite orientado para cima</li>
      </ul>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    const spriteW = 100, spriteH = 100;   // tamanho de cada frame no sprite sheet
    let frameIndex = 0;
    let frameCount = 1; // será calculado quando a imagem carregar

    const speedPxPerSec = 140; // velocidade ao longo do perímetro (px/s)
    let pos = 0;

    // --- Ajuste da orientação do ficheiro do sprite ---
    // Se o teu sprite "olha" para a direita por padrão, deixa 0.
    // Caso contrário, ajusta conforme os exemplos acima.
    let orientationOffset = 0; // ajuste que corrige a orientação do sprite

    // ângulo atual usado para desenho (suavizado)
    let currentAngle = 0;

    // image
    const image = new Image();
    image.src = 'images/sprite.png'; // garante que o ficheiro exista no caminho
    image.onload = () => {
      // calcula quantos frames verticais existem no sprite sheet
      frameCount = Math.max(1, Math.floor(image.height / spriteH));
      // inicializa animação
      requestAnimationFrame(animate);
    };

    // perímetro interior (o boneco respeita o tamanho do sprite)
    const pathLength = 2 * ((W - spriteW) + (H - spriteH));

    // helpers
    function getPosAndDir(p) {
      // devolve x,y e direção (dx,dy) - dx/dy são vetores de direção (-1,0,1)
      p = p % pathLength;
      if (p < (W - spriteW)) { // topo: esquerda -> direita
        return { x: p, y: 0, dx: 1, dy: 0 };
      }
      p -= (W - spriteW);
      if (p < (H - spriteH)) { // direita: topo -> baixo
        return { x: W - spriteW, y: p, dx: 0, dy: 1 };
      }
      p -= (H - spriteH);
      if (p < (W - spriteW)) { // baixo: direita -> esquerda
        return { x: (W - spriteW) - p, y: H - spriteH, dx: -1, dy: 0 };
      }
      p -= (W - spriteW);
      // esquerda: baixo -> cima
      return { x: 0, y: (H - spriteH) - p, dx: 0, dy: -1 };
    }

    // função para suavizar rotação (resolve wrap-around)
    function smoothAngle(current, target, t) {
      const PI2 = Math.PI * 2;
      let delta = (target - current) % PI2;
      if (delta > Math.PI) delta -= PI2;
      if (delta < -Math.PI) delta += PI2;
      return current + delta * t;
    }

    // animação
    let lastTime = 0;
    // controlamos frame do sprite a 15 fps
    const spriteFPS = 15;
    const spriteFrameInterval = 1000 / spriteFPS;
    let spriteFrameTimer = 0;

    function animate(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = timestamp - lastTime;
      lastTime = timestamp;

      // atualiza posição (consistente com dt)
      pos = (pos + speedPxPerSec * (dt / 1000)) % pathLength;

      // obtém posição e direção instantânea
      const info = getPosAndDir(pos);
      const x = info.x;
      const y = info.y;
      const dx = info.dx;
      const dy = info.dy;

      // calcular ângulo alvo a partir do vector de movimento
      // Math.atan2(y,x) usa (dy,dx)
      let targetAngle = Math.atan2(dy, dx) + orientationOffset;

      // suaviza rotação (0.2 é a "rapidez" da rotação; aumenta para rodar mais rápido)
      currentAngle = smoothAngle(currentAngle, targetAngle, 0.25);

      // atualizar frame do sprite (15 fps)
      spriteFrameTimer += dt;
      if (spriteFrameTimer >= spriteFrameInterval) {
        spriteFrameTimer -= spriteFrameInterval;
        frameIndex = (frameIndex + 1) % frameCount;
      }

      // desenhar
      ctx.clearRect(0, 0, W, H);

      // desenhar sprite com rotação em torno do centro do sprite
      ctx.save();
      ctx.translate(x + spriteW / 2, y + spriteH / 2); // mover origem para o centro do boneco
      ctx.rotate(currentAngle);
      // drawImage(source, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
      ctx.drawImage(
        image,
        0, frameIndex * spriteH, spriteW, spriteH,  // frame do sprite sheet (assume frames empilhados verticalmente)
        -spriteW / 2, -spriteH / 2, spriteW, spriteH // desenha centrado na origem
      );
      ctx.restore();

      // debug opcional: mostra vetor/direção no canto (descomenta se quiser)
      //ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0,0,120,26);
      //ctx.fillStyle = '#fff'; ctx.fillText(`dx:${dx} dy:${dy}`, 6, 14);

      requestAnimationFrame(animate);
    }

    // se quiseres forçar um offset (ex.: o sprite olha para cima no ficheiro),
    // descomenta UMA das linhas abaixo ou defi
